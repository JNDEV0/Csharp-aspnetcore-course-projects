//simple client console app to point at and test the running webapi server note the HttpVersion.Version30 requires setting up certificate in webapi
//!! the Identity package detects the password field of RegisterDTO in incoming request, and in fact only stores the hash value in the SQL database CustomUser serverside, if that CustomUser were returned to the user client, the password is only the hash value and not the string value entered by User, this automatic hashing of Password property is handled by Identity package of Aspnetcore to protect the user details, BUT the client will by default send plaintext in the request, so securing an HTTPS connection or encrypting the password BEFORE sending to server is important so the password is not readable when the user attempts to register or login

//the HttpClient relevant part is this operation, the API server address is stored in client app perhaps API_BASE_URL client sends POST request,
//with the RegisterDTO collected user inputs and client side validations performed,
//so the clientsideDTO is packaged to mirror the serverSide RegisterDTO, packaged into the post request and sent to server at website.com/api/account/register or custom route, remembering that this target controller serverside is tagged [AllowAnonymous] so the request skips identity user authentication
//clientside example: registration form data is filled out and confirmed in client/browser with user, while compiling/validating the inputs into the clientsideDTO,
//a Clientside AccountService sends the POST request with the register formData, then awaiting and handling the server response clientside, showing validation errors, reroute to success/login page after registration etc.

//client side form can be presented as HTML form elements and CSS styling on a browser, the form elements are validated client side using clientApp methods, provide visual feedback to user and prevent form sending if clientside validation fails, client collects user input and compiles into a request to server route, that parses the request into the serverside expected RegisterDTO format
//the client side program is completely separated from the server app, in this example its all in the same solution for study but the clientApp would be its own solution in production, the server would be the other three projects in this same solution, Core for domain level data models and DTOs which are then added as migration and updated to the database to create the tables, WebApi for the controller/services etc, Infra project has a CustomDbContext that implements IdentityDbContext and OnModelCreate inserted seed data for cities, so its very simplified as an implementation to showcase Identity package functionality, and migrated to database so the tables exist when users attempt actionMethod operations that access the database provider tables, such as PostRegister() or PostLogin() etc.
//note the default response of server in this example is returning a simple Ok() status code 200 response back to the client, in production this response could contain reroute instructions to a profile/confirmation page, initiate various auth-passed type tasks. client side validation/salvage/correct of user input values, like confirming password values match, phone number valid format, password and confirmPassword match serverside required formatting, etc 

//note the list of tables in the SQL database, the MigrationHistory is generated by code-first migrations to database, all the dbo.AspNetx tables are generated by the identity package to handle user auth tasks, users, roles, claims, token tables all were migrated in from the IdentityDbContext default generation

//login/logout
//the PostLogin and GetLogout actionmethods serverside call their internal services to handle the authentication and return the result here which may have some custom data, instructions on how to handle client side next steps, or no content depending on implementation. could redirect user to home page, invalidate session keys, etc. note also that Logout and Login return Task<IActionResult> here, even though various results can be returned like Ok, NoContent, Problem etc, including the nameless object with the user's name and email on login, all these fit as result of IActionResult, so the clientApp needs to handle the possible/expected results.
//when the user logs in the clientside is checking user input to send to the server, that will in fact validate if the login is valid against the database, the clientside will handle the result and displaying it to the user, for example the login response includes a user's registered name, and is displayed on the navbar as "hello userName", this can be a simple check if a clientside variable is null or has a value given by result to display the message and logout button instead of register/login buttons, when the logout button is clicked a request is sent to the logout API route of server, 

//JWT token
//in this example the Authresponse is received after login authentication, JWT token is retrieved from response and stored clientSide, as runtime variable, cache, localstorage on browser, cookies, etc 
//note the response is AuthResponseDTO contains readable properties along with the hashed JWToken value, at clientSide additional KVPs could be used to replace the "register" button with "hello Name", track token expiration to refresh etc
//the output string format Jwt token is a long string with mixed encoded and hashed segments, header.payload.signature explained in the JwtService class comments the clientside does not have any use for the token aside from attaching it to every new request sent to the server to signal the client is preauthed.
//after the response is received with the Jwt token and its stored in local storage or cache, its in the clientside memory/storage, now this localClient variable is passed along with authenticationRequired type requests to the server, once the server determines the JWT token is invalid, the user will have to login again, or implement token refresh for active sessions.
//remember the token will eventually (should)expire, so adapt the clientSide accordingly to remove/delete invalidated tokens from memory/storage, such as at logout, and implement graceful recovery when an expired/invalid token is used
//the clientSideApp then attaches a header to each request routed to controllers that require Authentication, to prove a valid ongoing logged-in unexpired session. the header key is "Authorization" and value $"Bearer {localStorage["token]}" equivalent string, if an invalid token is forged or taken from another user's session, it will fail validation since the token is userAutheitcation specific, which compiles userSpecific details into the token.
//so the server will recalculate the JWT with each incoming AuthExpected request, and compare it to the client-submitted JWT eventually the token expires after the set expiration and either refreshes or user login again,
//note format header Key:"Authorization" Value:"Bearer tokenString" is expected as a header to pass JWT validation serverside

using System.Net;
using System.Runtime.InteropServices;
using System.Text.Json;

namespace Client
{
    internal class ClientAuthResponse
    {
        public string? name { get; set; }
        public string? email { get; set; }
        public string token { get; set; }
        public DateTime? expiration { get;set; }
    }

    class App
    {
        public static async Task Main(string[] args)
        {
            //instantiating a basic HttpClient to send requests with
            var client = new HttpClient();

            //configuring and sending the loginRequest
            var loginRequest = new HttpRequestMessage(HttpMethod.Post, new Uri("https://localhost:7190/api/v1/account/login"))
            {
                Version = HttpVersion.Version20,

                //setting relevant to testing HTTP3 using Version30 above
                //VersionPolicy = HttpVersionPolicy.RequestVersionExact 
            };

            // email and password expected by the server, note that this simple example is sending the credentials in plain text to the server, in production this would not be sent before an encryption handshake was established for the connection, or if encryption is handled client/server side for each request
            var loginData = new
            {
                Email = "testuser4@xample.com",
                Password = "Password4"
            };

            // Serializing loginData to JSON and assigning to loginRequest
            loginRequest.Content = new StringContent(
                System.Text.Json.JsonSerializer.Serialize(loginData),
                System.Text.Encoding.UTF8,
                "application/json"
            );

            var loginResponse = await client.SendAsync(loginRequest);

            var GetCitiesRequest = new HttpRequestMessage(HttpMethod.Get, new Uri("https://localhost:7190/api/v1/cities"));

            //fetching the token from the loginRespose and attaching as a header to the auth required request to GetCities
            //string token = loginResponse.Headers.ToDictionary(k => k.Key, v => v.Value.FirstOrDefault()).First(h => h.Key == "token").Value.ToString();

            var loginResponseContent = await loginResponse.Content.ReadAsStringAsync();
            Console.WriteLine($"LoginResponse {loginResponse.StatusCode} content from server: {loginResponseContent} \br");

            ClientAuthResponse obj = JsonSerializer.Deserialize<ClientAuthResponse>(loginResponseContent);
            string token = obj.token;
            Console.WriteLine($"DEBUG here is the string received from login in the format it will be passed to GetCitiesRequest: Bearer {token}");

            GetCitiesRequest.Headers.Add("Authorization", $"Bearer {token}");

            Console.WriteLine("GetCitiesRequest Headers:");
            foreach (var reqHeader in GetCitiesRequest.Headers.ToDictionary())
            {
                Console.WriteLine($"key:{reqHeader.Key} value: {reqHeader.Value.First()}");
            }

            var GetCitiesResponse = await client.SendAsync(GetCitiesRequest);


            var getCitiesResponseContent = await GetCitiesResponse.Content.ReadAsStringAsync();
            var headers = GetCitiesResponse.Headers.ToDictionary(k => k.Key, v => v.Value.FirstOrDefault());

            Console.WriteLine($"GetCitiesResponse {GetCitiesResponse.StatusCode} content from server: {getCitiesResponseContent} \br");
            Console.WriteLine("GetCitiesResponse Headers:");
            foreach (var header in headers)
            {
                Console.WriteLine($"key:{header.Key} value: {header.Value}");
            }
        }
    }
}