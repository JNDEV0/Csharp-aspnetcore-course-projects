﻿/*
 this controller class is generated by vscode, the model City class was given with almost empty DbContext class, only stipulating a seed entry OnModelCreating
 a migration was added and updated to the database, that generated the timestamp_Initial_City code executed on the SQL database to create the tables and rows.

 the api methods below were generated for CRUD operations around the city class

NOTE!! the actionmethods of this route are locked behind authentication, and also tied to a specific issuer/audience, so without those being stipulated, all requests are denied! issuer and audience are the domain:port of the expected server and client using the Jwt for authorization.
 */
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using CitiesManager.Infra;
using CitiesManager.Core.Entities;
using Microsoft.CodeAnalysis;
using Asp.Versioning;
using CitiesManager.WebAPI.Controllers;
using Microsoft.AspNetCore.Authorization;

namespace Example.WebAPI.Controllers.v1
{
    //[Route("api/[controller]")]
    //[ApiController]
    //ApiController tag enables the route to read from request body in json format automatically
    //without this tag, the route will attempt to read from route appended query string,
    //or use [FromBody] tag given to parameter of City type at actionmethod
    //note also that the Route and ApiController tags as well as inheriting from ControllerBase is required for API
    //a parent CustomControllerBase class can be created, that inherits ControllerBase and applies the [tag] annotations
    //this way grandchild classes, like CitiesController and ExampleController on this example project, can inherit CustomControllerBase
    //and no longer need to repeat the [tags] for routing, and given the api/[controller] route being dynamic, uri wll still be api/example and api/cities

    //[Authorize()] //instead of setting authorize tag for each controller that should require valid JWT token, a global filter policy for all requests has been set at builder.Services.AddControllers, so this tag is on by default for all routes, EXCEPT [AllowAnonymous] tagged controllers, like the AccountController.cs 
    //note that aside from assigning api version, the controller or parent CustomControllerBase needs the [Route()] at some point, see CustomControllerBase
    [ApiVersion("1.0")]  //controller tag stipulates the "version" of this controller, see AddApiVersioning() @ Program.cs
    public class CitiesController : CustomControllerBase
    {
        private readonly AppDbContext _context;

        //in production, Dependency Injected Service classes with Inversion of Control interfaces
        //would be implemented instead of accessing DbContext here, with Data Transfer Object classes to isolate the Domain Layer data City.cs
        //the operations would be executed from here on the CustomService class that would in turn access CustomDbContext
        //by default from generated code and for example brevity the controller is accessing the DbContext directly for CRUD operations here
        public CitiesController(AppDbContext context)
        {
            _context = context;
        }

        // GET: api/Cities
        /// <summary>
        /// GET all Cities from Db
        /// </summary>
        /// <returns></returns>
        [HttpGet]
        //[Produces("application/xml")] //produces and consume tags can override default body type for a specific actionmethod, see Program.cs AddControllers()
        //[Consumes("application/xml")] //in this example the default is application/json, with these two tags GetCities would use application/xml in req. and resp.
        //ActionResult is the base class that implements IActionResult, and many other result classes are derived from ActionResult, like ContentResult, RedirectResult, OkResult, EmptyResult, StatusCodeResult,JsonResult, ViewComponentResult,ObjectResult, NotFoundResult, BadRequestResult, CreatedResult, UnauthorizedResult and NoContentResult
        //a few notes on the ActionResult, for example return type ActionResult with return statement Ok(object) is same as return type ActionResult<object> with return statement object, this is explained to show that these resultTypeMethods and the ActionResult classes work together
        //returning a ActionResult derived result class is best if the response should only be informative, returning IActionResult<T> is best for returning object responses, ObjectResult also derives from ActionResult>IActionResult
        public async Task<ActionResult<IEnumerable<City>>> GetCities()
        {
            //adding a custom header to add to the response the HTTP protocol used by the request
            //may be HTTP/1.1, 2 or 3, note that HTTP/3 requires valid encryption certificate so throws errors if unable to establish connection
            Response.Headers.Add("requesthttpversion", Request.Protocol);
            return await _context.Cities.ToListAsync();
        }

        // GET: api/Cities/5
        //note the <summary> xml comment, added right click actionmethod snippets>insert comment
        //XML comments for each actionmethod in controllers can be written and extracted to api.xml right click solution>properties>Build>output>enable API documentation>XMLDocumentationPath on solution build generates the output.xml file that swagger then can map the comments to each api endpoint in the UI display, useful for quick reference of each endpoint on swagger ui page, options need to be enabled at builder.Services.AddSwaggerGen() see Program.cs
        /// <summary>
        /// Receives HttpGet request, returns City object if found in Database, or 400 response
        /// </summary>
        /// <param name="customParameterName">GUID/UUID of City object to retrieve</param>
        /// <returns></returns>
        [HttpGet("{customParameterName}")] //the "{parameterName}" needs to match with the actionmethod parameter below, in this example was id by default
        public async Task<ActionResult<City>> GetCity(Guid customParameterName)
        {
            //var city = await _context.Cities.FindAsync(id);
            var city = await _context.Cities.FirstOrDefaultAsync(city => city.Id == customParameterName);

            if (city == null)
            {
                //NotFound and other similar methods intended to return a specific response type
                //exists in controller base class returns in this case NotFoundResult that inherits from statuscoderesult, that inherits from ActionResult, that implements IActionResult, with status code property 404 in response
                //this is explained to show how returning NotFound() is valid for the Task<ActionResult<City>> return type
                //return NotFound(); //returns 404 not found response

                //returning Problem is recommended to provide a structured response body instead of just a statuscode and error message
                //Problem can include relevant detail and also generates additional response fields like trace and type of standard response
                //any general purpose error can be adapted in Problem
                //Problem and validationProblem classes provides structured way of informing the clientside of issues in a standardized way
                //for example Problems.Errors.Id would be accessible in client side app on validationProblem response because of invalid city.Id
                return Problem(detail: "Invalid Id: city not found", statusCode: 400, title: "City Search");

                //valdiationProblem is specific for validation errors that occur duing model binding
                //this should not be used always, only when the client SHOULD know what the issue was
                //ValidationProblem has same properties as Problem, and an Errors collection,
                //to inform the client response of what issues were found
                //mutliple validaiton errors during model binding will automatically be added to the errors collection based on model binding validaiton annotations
                return ValidationProblem();
            }

            return city;
        }

        // PUT: api/Cities/5
        // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754
        [HttpPut("{id}")]
        //advisable to intentionally [Bind] the properties OF the given model class that are intended to be received with the request,
        //if no binding is given, properties that perhaps should not be included in the request could arrive with it, even made up KVPs,
        //for example a page that allows changing the city mayor name, but also stores a city office address that should never be changed,
        //if no binding is given to accept only mayorName from the incoming request body, someone could include a officeAddress value and it would be parsed in
        //this could be unintentional behaviour called "overposting", and possible security issue, thus the explanation
        //note [Bind(x,y)] for city parameter below names the properties to accept values for from incoming request body json
        public async Task<IActionResult> PutCity(Guid id, [Bind(nameof(City.Id), nameof(City.Name))] City city)
        {
            if (id != city.Id)
            {
                //badrequest is similar to NotFound() above, in the sense that its a statuscoderesult class that inherits actionResult and so on,
                //here with a 400 bad request response 
                return BadRequest();
            }

            //by default the generated code flags the EntityState as modified for the given city 
            //this can be an issue since it forces update on all fields of the city instance,
            //meaning if there are multiple properties and some are left null,
            //the update may replace values that were not intended to be modified
            //_context.Entry(city).State = EntityState.Modified;

            var foundCity = await _context.Cities.FindAsync(id);

            if (foundCity == null)
            {
                return NotFound();
            }

            //if foundCity is not null here we manually edit the intended values, could be a switch here
            foundCity.Name = city.Name;

            try
            {
                await _context.SaveChangesAsync();
            }
            //this exception has to do with optimistic concurrency where the app attempts to access the given object
            //BUT if it is already in use by another thread, this error will be thrown, very basic but avoids deadlocks
            //in production the request could be in a pool of pending changes rather than discarded
            catch (DbUpdateConcurrencyException)
            {
                if (!CityExists(id))
                {
                    return NotFound();
                }
                else
                {
                    throw;
                }
            }

            return NoContent(); //200 no content response
        }

        // POST: api/Cities
        // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754
        [HttpPost]
        public async Task<ActionResult<City>> PostCity([Bind(nameof(City.Id), nameof(City.Name))] City city)
        {
            //no validation is being done here beyond basic binding, normally the model class would be a DTO class with various validation [annotation] tags on each property
            //then the DbSet has the target city added to it
            _context.Cities.Add(city);
            //and changes are saved to the DB provider
            await _context.SaveChangesAsync();

            //CreatedAtAction takes the name of the other actionMethod to call, in this case GetCity, it expects the customParameterName to match see GetCity() method,
            //the second param is anon object with expected customParameterName prop with value of the city's id.
            //the third param is the city object incoming from request, which will become response in being returned by CreatedAtAction
            //CreatedAtAction will return a result 200 response with a "Location" header that points to the full uri with GUID to GetCity() the posted/added city, this is useful if the item needs to be retrieved clientside
            return CreatedAtAction("GetCity", new { customParameterName = city.Id }, city);
        }

        // DELETE: api/Cities/5
        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteCity(Guid id)
        {
            var city = await _context.Cities.FindAsync(id);
            if (city == null)
            {
                return NotFound();
            }

            _context.Cities.Remove(city);
            await _context.SaveChangesAsync();

            return NoContent();
        }

        private bool CityExists(Guid id)
        {
            return _context.Cities.Any(e => e.Id == id);
        }
    }
}
